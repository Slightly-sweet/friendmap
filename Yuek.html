<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…è®¸ç”¨æˆ·ç¼©æ”¾ (user-scalable=yes) ä»¥ä¾¿æŸ¥çœ‹ç»†èŠ‚ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Yuek's Friend Map V3.0</title>
    <!-- å¼•å…¥ D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #0b0c10;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            overflow: hidden; /* é˜²æ­¢èƒŒæ™¯æ»šåŠ¨ï¼Œä½†å…è®¸ç”»å¸ƒå†…æ“ä½œ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            touch-action: none; /* ä¼˜åŒ–è§¦æ§ä½“éªŒ */
        }

        /* æ‚¬åœå¡ç‰‡ */
        #tooltip {
            position: absolute;
            opacity: 0;
            background: rgba(16, 20, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(102, 252, 241, 0.3);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            width: 240px; /* å›ºå®šå®½åº¦é˜²æ­¢è¿‡å®½ */
            z-index: 999;
            transition: opacity 0.2s ease;
            /* ç§»é™¤ transformï¼Œæ”¹ç”¨ JS åŠ¨æ€è®¡ç®—ä½ç½® */
        }
        #tooltip h3 { margin: 0 0 5px 0; color: #66fcf1; font-size: 1.1em; }
        #tooltip .tags { display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap; }
        #tooltip .tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #c5c6c7; }
        #tooltip p { margin: 0; font-size: 0.9em; line-height: 1.5; color: #fff; word-wrap: break-word; }

        /* æ§åˆ¶é¢æ¿å¼€å…³ */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .switch { position: relative; display: inline-block; width: 36px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #66fcf1; }
        input:checked + .slider:before { transform: translateX(18px); }

        .star { position: absolute; background: white; border-radius: 50%; opacity: 0.5; animation: twinkle 3s infinite; pointer-events: none; }
        @keyframes twinkle { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; } }
        
        /* åœˆå­æ ‡ç­¾æ ·å¼ */
        .group-label { font-size: 12px; fill: rgba(255,255,255,0.6); pointer-events: none; text-shadow: 0 0 3px black; }
    </style>
</head>
<body>

    <div id="tooltip"></div>

    <div class="controls">
        <span>æ˜¾ç¤ºåœˆå­/è¿çº¿</span>
        <label class="switch">
            <input type="checkbox" id="toggleRelations" checked>
            <span class="slider"></span>
        </label>
    </div>

    <script>
        // ==========================================
        // ğŸ› ï¸ æ•°æ®é…ç½®åŒºåŸŸ
        // ==========================================

        const customOrder = ["åˆä¸­", "é«˜ä¸­", "æœ¬ç§‘", "ç¡•å£«", "å®ä¹ "];

        // 1. æœ‹å‹æ•°æ® (ä¿ç•™äº†ä½ çš„æ•°æ®)
        const friendsData = [
            // --- åˆä¸­ ---
            { id: "M01", name: "ä¸¸è€å¸ˆ", stage: "åˆä¸­", distance: 6, contact: true, gender: "å¥³", mbti: "INFJ", personality: "æ·¡æ·¡çš„ç»¿è€å¤´", story: "æ·¡æ·¡çš„ç»¿è€å¤´ã€‚" },
            { id: "M02", name: "ç‹—å­", stage: "åˆä¸­", distance: 6, contact: true, gender: "ç”·", mbti: "ISFJ", personality: "é“å¾·æ ‡å…µ", story: "è€å®äººä¸€æšã€‚" },
            { id: "M03", name: "xx", stage: "åˆä¸­", distance: 51, contact: false, gender: "ç”·", mbti: "ISFP", personality: "", story: "2019ä¹‹åå°±æ²¡è§è¿‡é¢æƒ¹ï¼Œç›®å‰ä»…æœ‹å‹åœˆç‚¹èµä¹‹äº¤ã€‚" },
        
            // --- é«˜ä¸­ ---
            { id: "H01", name: "kiki", stage: "é«˜ä¸­", distance: 11, contact: true, gender: "å¥³", mbti: "ISTJ", personality: "äº’è”ç½‘HR", story: "å”¯ä¸€ä¸€ä¸ªä¼šæ‰“è¯­éŸ³èŠçƒ¦æ¼çš„æœ‹å‹ï¼Œä¸€èµ·å»è¿‡ä¸Šæµ·è¿ªå£«å°¼ã€‚" },
            { id: "H02", name: "ruojia", stage: "é«˜ä¸­", distance: 16, contact: true, gender: "å¥³", mbti: "INFP", personality: "äºŒæ¬¡å…ƒ", story: "å…±åŒçˆ±å¥½æœ€å¤šçš„æœ‹å‹ï¼ˆè€½ç¾/ä¹™æ¸¸ï¼‰ã€‚" },
            { id: "H03", name: "dudu", stage: "é«˜ä¸­", distance: 21, contact: true, gender: "å¥³", mbti: "", personality: "ç†ç§‘ç™½ç—´", story: "é«˜ä¸‰åŒæ¡Œï¼Œäº’ç›¸é¼“åŠ±çš„é©å‘½å‹è°Šã€‚" },
            { id: "H04", name: "fanfan", stage: "é«˜ä¸­", distance: 26, contact: true, gender: "å¥³", mbti: "ENFJ", personality: "", story: "ç°åœ¨åœ¨ç¾å›½å·¥ä½œï¼Œåœ£è¯èŠ‚å›å¹¿å·è§çš„æœ‹å‹ã€‚" },
            { id: "H05", name: "å¤§å˜´å¥", stage: "é«˜ä¸­", distance: 91, contact: false, gender: "ç”·", mbti: "ENFP", personality: "ç‹æœ‹ç‹—å‹", story: "ç°åœ¨ä»…æœ‹å‹åœˆç‚¹èµè¯„è®ºä¹‹äº¤ï¼Œ0ç§èŠã€‚" },
        
            // --- æœ¬ç§‘ ---
            { id: "U01", name: "è¾£å­", stage: "æœ¬ç§‘", distance: 13, contact: true, gender: "å¥³", mbti: "INFJ", personality: "æ··å­ç»„", story: "ç»å¸¸ç†¬å¤œçš„å¹¿å‘Šäººã€‚å†°æ²™äº‹ä»¶ä¸»äººå…¬ã€‚" },
            { id: "U02", name: "çƒçƒ", stage: "æœ¬ç§‘", distance: 21, contact: true, gender: "å¥³", mbti: "INFJ", personality: "æ··å­ç»„", story: "åœ¨é¦™æ¸¯è¯»ç ”ã€‚å†°æ²™äº‹ä»¶å«Œç–‘äººã€‚" },
            { id: "U03", name: "å¦®", stage: "æœ¬ç§‘", distance: 28, contact: true, gender: "å¥³", mbti: "", personality: "å®¤å‹", story: "å…³ç³»æœ€å¥½çš„å®¤å‹ã€‚" },
            { id: "U04", name: "éŸµå§", stage: "æœ¬ç§‘", distance: 28, contact: true, gender: "å¥³", mbti: "", personality: "å®¤å‹", story: "é™ªæˆ‘å»æ€¥è¯Šçš„å®¤å‹ã€‚" },
            { id: "U05", name: "ç¾Š", stage: "æœ¬ç§‘", distance: 29, contact: true, gender: "å¥³", mbti: "", personality: "å®¤å‹", story: "äº’è”ç½‘äº§å“åŒè¡Œ:) äº§å“å¯è’™äººã€‚" },
            { id: "U06", name: "é¥¼é¥¼", stage: "æœ¬ç§‘", distance: 41, contact: true, gender: "å¥³", mbti: "INFP", personality: "æ··å­ç»„", story: "è§åˆ°ç”·æœ‹å‹å°±ä¸å’Œæˆ‘è¯´è¯ã€‚å†°æ²™äº‹ä»¶å«Œç–‘äººã€‚" },
        
            // --- ç¡•å£« ---
            { id: "G01", name: "é¸­è€å¸ˆ", stage: "ç¡•å£«", distance: 29, contact: true, gender: "å¥³", mbti: "ENFP", personality: "è¿½æ˜Ÿæ­å­", story: "åŒæ‹…ï¼Œä¼šä¸€èµ·å–é…’çš„æœ‹å‹ã€‚" },
            { id: "G02", name: "å°æ—è€å¸ˆ", stage: "ç¡•å£«", distance: 31, contact: true, gender: "å¥³", mbti: "INTJ", personality: "å®¤å‹", story: "è¾¹ç•Œæ„Ÿå¾ˆå¼ºï¼Œä¿©äº§å“æ¢å­ã€‚" },
            { id: "G03", name: "å°åˆ˜", stage: "ç¡•å£«", distance: 36, contact: true, gender: "å¥³", mbti: "INFJ", personality: "ç ”å‹", story: "ä¸€èµ·å¤‡è€ƒå¤è¯•çš„å­¦ç¡•åŒå­¦ã€‚" },
        
            // --- å®ä¹  ---
            { id: "I01", name: "æ‰æ‰", stage: "å®ä¹ ", distance: 11, contact: true, gender: "å¥³", mbti: "ENFP", personality: "bilibili", story: "è¯»ç ”åæœ€äº²å¯†çš„æœ‹å‹ï¼Œæƒ…æ„Ÿå¼•è·¯äººã€‚" },
            { id: "I02", name: "æŸ³ä¸å“¥", stage: "å®ä¹ ", distance: 23, contact: true, gender: "ç”·", mbti: "ISFJ", personality: "bilibili", story: "ç«æ˜Ÿæ’åœ°çƒçš„å…³ç³»ã€‚" },
            { id: "I03", name: "qqå°å†°", stage: "å®ä¹ ", distance: 26, contact: true, gender: "å¥³", mbti: "INFJ", personality: "mi", story: "åˆå¾—æ¥ä½†è§‚å¿µæœ‰äº›ä¸ä¸€æ ·ã€‚" },
        ];

        // 2. â­•ï¸ åœˆå­æ•°æ® (æ–°å¢åŠŸèƒ½)
        // names: å¿…é¡»å’Œä¸Šé¢çš„ name å®Œå…¨ä¸€è‡´
        const groupsData = [
            { 
                names: ["è¾£å­", "çƒçƒ", "é¥¼é¥¼"], 
                label: "å†°æ²™äº‹ä»¶ç»„", 
                color: "#ff00ff" // åœˆå­çš„é¢œè‰²
            },
            {
                names: ["å¦®", "éŸµå§", "ç¾Š"],
                label: "æœ¬ç§‘å¥½å®¤å‹",
                color: "#00ffff"
            }
        ];

        // 3. è¿çº¿æ•°æ® (ç‚¹å¯¹ç‚¹)
        const relationsData = [
             { source: "é¸­è€å¸ˆ", target: "å°æ—è€å¸ˆ", label: "æ ¡å‹", type: "dotted", arrow: false }
        ];

        // ==========================================
        // âš™ï¸ æ ¸å¿ƒé€»è¾‘
        // ==========================================

        function init() {
            d3.select("body").selectAll("svg").remove();

            const width = window.innerWidth;
            const height = window.innerHeight;
            // é€‚é…ç¼©æ”¾ï¼šåŠå¾„ç¨å¾®è°ƒå°ä¸€ç‚¹ï¼Œç•™å‡ºæ›´å¤šç©ºéš™ç»™åœˆå­
            const maxRadius = Math.min(width, height) * 0.40; 
            const centerRadius = 25;

            // æ”¯æŒ D3 Zoom (ç”»å¸ƒå¹³ç§»ç¼©æ”¾)
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3]) // ç¼©æ”¾èŒƒå›´
                .on("zoom", (e) => mainG.attr("transform", e.transform));

            const svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(zoom) // ç»‘å®šç¼©æ”¾
                .on("dblclick.zoom", null); // ç¦ç”¨åŒå‡»æ”¾å¤§

            const mainG = svg.append("g")
                .attr("transform", `translate(${width/2}, ${height/2})`); // åˆå§‹å±…ä¸­

            // --- ç®­å¤´å®šä¹‰ ---
            const defs = svg.append("defs");
            defs.append("marker").attr("id", "arrow").attr("viewBox", "0 -5 10 10")
                .attr("refX", 18).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6)
                .attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", "#66fcf1");
            
            const filter = defs.append("filter").attr("id", "glow");
            filter.append("feGaussianBlur").attr("stdDeviation", "2.5").attr("result", "coloredBlur");
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode").attr("in", "coloredBlur");
            feMerge.append("feMergeNode").attr("in", "SourceGraphic");

            // --- æ•°æ®å¤„ç† ---
            const stageCounts = d3.rollups(friendsData, v => v.length, d => d.stage);
            const stageMap = new Map(stageCounts);
            let allStages = Array.from(stageMap.keys());
            allStages.sort((a, b) => {
                let ia = customOrder.indexOf(a); let ib = customOrder.indexOf(b);
                if (ia === -1) ia = 999; if (ib === -1) ib = 999;
                return ia - ib;
            });

            const pie = d3.pie().value(d => stageMap.get(d)).sort(null).padAngle(0.08);
            const arcs = pie(allStages);
            const angleMap = {};
            arcs.forEach(d => {
                angleMap[d.data] = { start: d.startAngle, end: d.endAngle, mid: (d.startAngle + d.endAngle) / 2 };
            });

            // --- ç»˜åˆ¶èƒŒæ™¯æ‰‡åŒº ---
            const sectorG = mainG.append("g").attr("class", "sectors");
            arcs.forEach(d => {
                const r = maxRadius + 40;
                const midAngle = (d.startAngle + d.endAngle) / 2;
                const labelX = Math.sin(midAngle) * r;
                const labelY = -Math.cos(midAngle) * r;
                
                // æ‰‡åŒºåˆ†å‰²çº¿
                const lineX = Math.sin(d.startAngle) * (maxRadius + 20);
                const lineY = -Math.cos(d.startAngle) * (maxRadius + 20);
                sectorG.append("line").attr("x1", 0).attr("y1", 0).attr("x2", lineX).attr("y2", lineY)
                    .attr("stroke", "rgba(255,255,255,0.05)").attr("stroke-dasharray", "4,4");
                
                sectorG.append("text").attr("x", labelX).attr("y", labelY)
                    .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
                    .attr("fill", "#888").attr("font-size", "14px").text(d.data);
            });

            // --- è®¡ç®—èŠ‚ç‚¹ä½ç½® ---
            const radiusScale = d3.scaleLinear().domain([0, 100]).range([centerRadius + 20, maxRadius]);
            const nodes = friendsData.map(d => {
                const angleInfo = angleMap[d.stage];
                const angle = angleInfo.mid + (Math.random() - 0.5) * 0.2; // ç¨å¾®éšæœº
                const r = radiusScale(d.distance);
                const targetX = Math.sin(angle) * r;
                const targetY = -Math.cos(angle) * r;
                return { ...d, x: targetX, y: targetY, targetX, targetY, radius: d.distance < 20 ? 15 : 10 };
            });

            // ç‰©ç†é˜²é‡å 
            const simulation = d3.forceSimulation(nodes)
                .force("x", d3.forceX(d => d.targetX).strength(0.8))
                .force("y", d3.forceY(d => d.targetY).strength(0.8))
                .force("collide", d3.forceCollide(d => d.radius + 8).iterations(3))
                .stop();
            for (let i = 0; i < 200; i++) simulation.tick();

            // æ„å»º name æ˜ å°„
            const nameToNode = {};
            nodes.forEach(n => nameToNode[n.name] = n);

            // --- âš ï¸ ç»˜åˆ¶åœˆå­å±‚ (Group Hulls) ---
            const groupG = mainG.append("g").attr("class", "group-layer");
            
            // å‡¸åŒ…ç”Ÿæˆå‡½æ•° (ä½¿ç”¨ CatmullRom æ›²çº¿è®©å¤šè¾¹å½¢åœ†æ¶¦)
            const curveLine = d3.line().curve(d3.curveCatmullRomClosed.alpha(0.5));

            groupsData.forEach(g => {
                // æ‰¾åˆ°è¯¥ç»„çš„æ‰€æœ‰èŠ‚ç‚¹åæ ‡
                const groupNodes = g.names.map(name => nameToNode[name]).filter(n => n);
                if (groupNodes.length < 2) return; // å°‘äº2äººä¸ç”»åœˆ

                // è·å–ç‚¹é›†ï¼Œå¹¶å‘å¤–æ‰©å¼ ä¸€ç‚¹ç‚¹åš padding
                const points = groupNodes.map(n => [n.x, n.y]);
                const hull = d3.polygonHull(points);

                // å¦‚æœ hull è®¡ç®—å¤±è´¥ï¼ˆä¾‹å¦‚å…±çº¿ï¼‰ï¼Œç›´æ¥é€€åŒ–ä¸ºç®€å•è¿çº¿ï¼Œå¦åˆ™ç»˜åˆ¶ hull
                // ä¸ºäº†è§†è§‰ç¾è§‚ï¼Œæˆ‘ä»¬åœ¨ stroke-width ä¸Šåšæ–‡ç« æ¥æ¨¡æ‹Ÿåœ†è§’åŒ…å›´
                if (hull || groupNodes.length >= 2) {
                    const pathData = hull ? curveLine(hull) : curveLine(points);
                    
                    const groupPath = groupG.append("path")
                        .attr("d", pathData)
                        .attr("fill", g.color)
                        .attr("fill-opacity", 0.15) // ææ·¡çš„èƒŒæ™¯
                        .attr("stroke", g.color)
                        .attr("stroke-width", 35) // â­ï¸ å…³é”®ï¼šç”¨è¶…ç²—çš„æè¾¹æ¥åŒ…è£¹èŠ‚ç‚¹
                        .attr("stroke-opacity", 0.15)
                        .attr("stroke-linejoin", "round"); // åœ†è§’è¿æ¥

                    // è®¡ç®—ä¸­å¿ƒç‚¹æ”¾æ ‡ç­¾
                    const centroid = hull ? d3.polygonCentroid(hull) : [
                        d3.mean(points, p => p[0]), d3.mean(points, p => p[1])
                    ];
                    
                    groupG.append("text")
                        .attr("class", "group-label")
                        .attr("x", centroid[0])
                        .attr("y", centroid[1])
                        .attr("text-anchor", "middle")
                        .attr("dy", 4)
                        .text(g.label);
                }
            });

            // --- ç»˜åˆ¶è¿çº¿ (ç‚¹å¯¹ç‚¹) ---
            const relationsG = mainG.append("g").attr("class", "relations-layer");
            const validRelations = relationsData.filter(r => nameToNode[r.source] && nameToNode[r.target]);
            
            relationsG.selectAll("path").data(validRelations).enter().append("path")
                .attr("d", d => `M${nameToNode[d.source].x},${nameToNode[d.source].y} L${nameToNode[d.target].x},${nameToNode[d.target].y}`)
                .attr("stroke", "#66fcf1").attr("stroke-width", 1.5).attr("stroke-opacity", 0.5)
                .attr("fill", "none").attr("stroke-dasharray", d => d.type === 'dotted' ? "2,2" : "0")
                .attr("marker-end", d => d.arrow ? "url(#arrow)" : null);

            // --- ç»˜åˆ¶åœ†å¿ƒè¿çº¿ (è¡Œæ˜Ÿè½¨é“) ---
            // éœ€æ±‚ï¼šä¸è”ç³»çš„è¡Œæ˜Ÿåœ†åœˆä¹Ÿç”¨è™šçº¿
            const centerLinksG = mainG.append("g");
            centerLinksG.selectAll("line").data(nodes).enter().append("line")
                .attr("x1", 0).attr("y1", 0).attr("x2", d => d.x).attr("y2", d => d.y)
                .attr("stroke", d => d.gender === "å¥³" ? "#ff4d94" : "#00d2ff")
                .attr("stroke-width", 1).attr("opacity", 0.25)
                .attr("stroke-dasharray", d => d.contact ? "0" : "4,4");

            // --- ç»˜åˆ¶èŠ‚ç‚¹ ---
            const nodesG = mainG.append("g");
            const circles = nodesG.selectAll("circle").data(nodes).enter().append("circle")
                .attr("cx", d => d.x).attr("cy", d => d.y)
                .attr("r", d => d.distance < 20 ? 12 : 7)
                // â­ï¸ è§†è§‰ä¿®æ”¹ï¼šå¦‚æœ contact=falseï¼Œåˆ™ç©ºå¿ƒ+è™šçº¿æè¾¹
                .attr("fill", d => d.contact ? (d.gender === "å¥³" ? "#ff4d94" : "#00d2ff") : "transparent")
                .attr("stroke", d => d.gender === "å¥³" ? "#ff4d94" : "#00d2ff")
                .attr("stroke-width", d => d.contact ? (d.distance < 20 ? 2 : 0) : 2) // ä¸è”ç³»çš„ç»™2pxæè¾¹
                .attr("stroke-dasharray", d => d.contact ? "0" : "3,2") // ä¸è”ç³»çš„ç»™è™šçº¿
                .style("filter", d => d.contact ? "url(#glow)" : "none") // ä¸è”ç³»çš„ä¸å‘å…‰
                .style("opacity", d => d.contact ? 0.9 : 0.6) // ä¸è”ç³»çš„ç¨å¾®æ·¡ä¸€ç‚¹
                .style("cursor", "pointer");

            // --- ç»˜åˆ¶æˆ‘ ---
            const me = mainG.append("g").style("filter", "url(#glow)");
            me.append("circle").attr("r", 18).attr("fill", "#ffd700");
            me.append("text").attr("y", 5).attr("text-anchor", "middle").attr("font-size", "10px").attr("font-weight","bold").text("æˆ‘");

            // --- äº¤äº’é€»è¾‘ (Tooltip æ™ºèƒ½é˜²æº¢å‡º) ---
            const tooltip = d3.select("#tooltip");

            circles.on("click", function(event, d) {
                // ç§»åŠ¨ç«¯ç‚¹å‡»äº¤äº’ä¼˜åŒ–
                event.stopPropagation();
                showTooltip(event, d, this);
            });

            circles.on("mouseover", function(event, d) {
                // PCç«¯æ‚¬åœ
                showTooltip(event, d, this);
            }).on("mouseout", hideTooltip);

            // ç‚¹å‡»ç©ºç™½å¤„éšè—
            svg.on("click", hideTooltip);

            function showTooltip(event, d, element) {
                // é«˜äº®åŠ¨ç”»
                d3.select(element).transition().attr("r", 18);

                let tagsHtml = `<span class="tag">${d.stage}</span>`;
                if(d.mbti) tagsHtml += `<span class="tag">${d.mbti}</span>`;
                if(d.personality) tagsHtml += `<span class="tag">${d.personality}</span>`;
                
                tooltip.html(`
                    <h3>${d.name} <span style="font-size:0.7em;opacity:0.6">${d.contact?"":"(å¤±è”)"}</span></h3>
                    <div class="tags">${tagsHtml}</div>
                    <p>â€œ${d.story}â€</p>
                `);

                // ğŸ“ æ™ºèƒ½ä½ç½®è®¡ç®—
                const tWidth = 240; // Tooltip width
                const tHeight = tooltip.node().offsetHeight || 150; // Estimate height
                const margin = 20;

                // è·å–è§¦æ‘¸ç‚¹æˆ–é¼ æ ‡ä½ç½®
                let pageX = event.pageX || (event.touches && event.touches[0].pageX);
                let pageY = event.pageY || (event.touches && event.touches[0].pageY);

                // é»˜è®¤ä½ç½®ï¼šå³ä¸‹æ–¹
                let left = pageX + 15;
                let top = pageY + 15;

                // æ£€æŸ¥å³è¾¹ç¼˜
                if (left + tWidth > window.innerWidth) {
                    left = pageX - tWidth - 15; // æ”¾åˆ°å·¦è¾¹
                }
                // æ£€æŸ¥ä¸‹è¾¹ç¼˜
                if (top + tHeight > window.innerHeight) {
                    top = pageY - tHeight - 15; // æ”¾åˆ°ä¸Šæ–¹
                }

                tooltip.style("opacity", 1)
                       .style("left", left + "px")
                       .style("top", top + "px");
            }

            function hideTooltip() {
                circles.transition().attr("r", d => d.distance < 20 ? 12 : 7);
                tooltip.style("opacity", 0);
            }

            // å¼€å…³æ§åˆ¶
            const toggle = document.getElementById('toggleRelations');
            function updateRelations() {
                const opacity = toggle.checked ? 1 : 0;
                relationsG.transition().duration(400).style("opacity", opacity);
                groupG.transition().duration(400).style("opacity", opacity);
            }
            toggle.addEventListener('change', updateRelations);
        }

        function createStars() {
            for(let i=0; i<100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                const size = Math.random() * 2;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.left = Math.random() * 100 + 'vw';
                star.style.top = Math.random() * 100 + 'vh';
                star.style.animationDuration = (Math.random() * 3 + 2) + 's';
                document.body.appendChild(star);
            }
        }

        createStars();
        init();

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(init, 300);
        });
    </script>
</body>
</html>
