<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æˆ‘çš„æ˜Ÿç³»å¼•åŠ›å›¾ V2.0</title>
    <!-- å¼•å…¥ D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #0b0c10;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }

        /* æ‚¬åœå¡ç‰‡ */
        #tooltip {
            position: absolute;
            opacity: 0;
            background: rgba(16, 20, 30, 0.85); /* æ·±è‰²èƒŒæ™¯æ›´æ¸…æ™° */
            backdrop-filter: blur(12px);
            border: 1px solid rgba(102, 252, 241, 0.3);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            max-width: 260px;
            z-index: 20;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translate(-50%, -110%);
        }
        #tooltip h3 { margin: 0 0 5px 0; color: #66fcf1; font-size: 1.1em; }
        #tooltip .tags { display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap; }
        #tooltip .tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #c5c6c7; }
        #tooltip p { margin: 0; font-size: 0.9em; line-height: 1.5; color: #fff; }

        /* æ§åˆ¶é¢æ¿å¼€å…³ */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        /* å¼€å…³æ ·å¼ */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #66fcf1; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* æ˜Ÿæ˜ŸèƒŒæ™¯ */
        .star { position: absolute; background: white; border-radius: 50%; opacity: 0.5; animation: twinkle 3s infinite; }
        @keyframes twinkle { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; } }
    </style>
</head>
<body>

    <!-- æ‚¬æµ®æç¤º -->
    <div id="tooltip"></div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="controls">
        <span>æ˜¾ç¤ºäººç‰©å…³ç³»ç½‘</span>
        <label class="switch">
            <input type="checkbox" id="toggleRelations" checked>
            <span class="slider"></span>
        </label>
    </div>

    <script>
        // ==========================================
        // ğŸ› ï¸ æ•°æ®é…ç½®åŒºåŸŸ (è¯·ä¿®æ”¹è¿™é‡Œ)
        // ==========================================

        // 1. é˜¶æ®µæ’åºè®¾ç½® (æ²¡å†™åœ¨è¿™é‡Œçš„é˜¶æ®µä¼šè‡ªåŠ¨å½’ç±»åˆ°æœ€å)
        // è¿™é‡Œæ§åˆ¶äº†æ‰‡å½¢æ’åˆ—çš„é¡ºåº
        const customOrder = ["å°å­¦", "åˆä¸­", "é«˜ä¸­", "å¤§å­¦", "ç ”ç©¶ç”Ÿ", "å®ä¹ ", "ç¤¾å›¢", "ç½‘å‹"];

        // 2. æœ‹å‹æ•°æ®æ¸…å•
        // mbti å’Œ personality å¦‚æœæ²¡æœ‰ï¼Œå¯ä»¥ç•™ç©ºå­—ç¬¦ä¸² "" æˆ–è€… null
        const friendsData = [
            { id: "A01", name: "å°A", stage: "ç ”ç©¶ç”Ÿ", distance: 15, contact: true, gender: "å¥³", mbti: "ENFP", personality: "å¿«ä¹å°ç‹—", story: "ç ”ä¸€æœ€å´©æºƒçš„æ—¶å€™é™ªæˆ‘é€šå®µæ”¹è®ºæ–‡ï¼Œè¿˜ç»™æˆ‘ç…®é¢åƒã€‚" },
            { id: "A02", name: "å¸ˆå…„B", stage: "ç ”ç©¶ç”Ÿ", distance: 40, contact: true, gender: "ç”·", mbti: "INTJ", personality: "é«˜å†·æ¯’èˆŒ", story: "å¸¦æˆ‘å…¥é—¨å®éªŒå®¤çš„å¤§ç¥ï¼Œè™½ç„¶æ¯•ä¸šäº†ä½†ä¾ç„¶ä¼šæŒ‡å¯¼æˆ‘ã€‚" },
            { id: "B01", name: "å°èŠ±", stage: "å¤§å­¦", distance: 20, contact: true, gender: "å¥³", mbti: "", personality: "æ¸©æŸ”å€¾å¬", story: "å¤§å­¦å››å¹´çš„é¥­æ­å­ï¼Œä¹Ÿæ˜¯æˆ‘çš„æƒ…æ„Ÿåƒåœ¾æ¡¶ã€‚" },
            { id: "B02", name: "ç¤¾é•¿C", stage: "å¤§å­¦", distance: 60, contact: false, gender: "ç”·", mbti: "ENTJ", personality: "", story: "æ›¾ç»ä¸€èµ·åŠè¿‡æœ€å¤§çš„æ´»åŠ¨ï¼Œæ•™ä¼šæˆ‘ä»€ä¹ˆæ˜¯é¢†å¯¼åŠ›ã€‚" },
            { id: "C01", name: "åŒæ¡ŒD", stage: "é«˜ä¸­", distance: 30, contact: true, gender: "å¥³", mbti: "ISFP", personality: "è‰ºæœ¯æ°”è´¨", story: "é™ªæˆ‘é€ƒæ™šè‡ªä¹ çœ‹æ˜Ÿæ˜Ÿçš„äººã€‚" },
            { id: "C02", name: "è€ç­", stage: "é«˜ä¸­", distance: 80, contact: false, gender: "ç”·", mbti: "", personality: "ä¸¥å‰", story: "å”¯ä¸€åŠæˆ‘ä¸è¦æ”¾å¼ƒæ•°å­¦çš„äººã€‚" },
            { id: "D01", name: "Mentor E", stage: "å®ä¹ ", distance: 50, contact: true, gender: "å¥³", mbti: "ESTJ", personality: "é›·å‰é£è¡Œ", story: "èŒåœºå¼•è·¯äººã€‚" },
            { id: "E01", name: "å‘å°F", stage: "å°å­¦", distance: 10, contact: true, gender: "å¥³", mbti: "INFP", personality: "æ²»æ„ˆç³»", story: "è®¤è¯†20å¹´äº†ï¼Œä¸éœ€è¦è¯´è¯å°±çŸ¥é“å¯¹æ–¹åœ¨æƒ³ä»€ä¹ˆã€‚" },
            { id: "F01", name: "é©´å‹G", stage: "ç½‘å‹", distance: 45, contact: false, gender: "ç”·", mbti: "", personality: "å¹½é»˜", story: "ä¸€èµ·å»è¿‡è¥¿è—ï¼Œç”Ÿæ­»ä¹‹äº¤ã€‚" },
        ];

        // 3. æœ‹å‹é—´çš„å…³ç³»è¿çº¿ (é«˜çº§åŠŸèƒ½)
        // source å’Œ target å¿…é¡»å¡«ä¸Šé¢çš„ name (å§“å)
        const relationsData = [
            { source: "å°A", target: "å¸ˆå…„B", label: "æ¬¢å–œå†¤å®¶", type: "dotted", arrow: false },
            { source: "å°èŠ±", target: "ç¤¾é•¿C", label: "å‰ä»»", type: "solid", arrow: true }, 
            { source: "å°A", target: "å°èŠ±", label: "ä»‹ç»è®¤è¯†", type: "dashed", arrow: true } 
        ];

        // ==========================================
        // âš™ï¸ æ ¸å¿ƒä»£ç é€»è¾‘ (æ— éœ€ä¿®æ”¹)
        // ==========================================

        // 1. åˆå§‹åŒ–ç”»å¸ƒä¸å“åº”å¼è®¾ç½®
        function init() {
            // æ¸…ç©ºæ—§å›¾ (ç”¨äºResizeæ—¶é‡ç»˜)
            d3.select("body").selectAll("svg").remove();

            const width = window.innerWidth;
            const height = window.innerHeight;
            // å“åº”å¼åŠå¾„ï¼šå–é•¿å®½è¾ƒå°å€¼çš„45%ä½œä¸ºæœ€å¤§åŠå¾„ï¼Œä¿è¯ä¸è¶…å‡ºå±å¹•
            const maxRadius = Math.min(width, height) * 0.45;
            const centerRadius = 20; // ä¸­å¿ƒçš„â€œæˆ‘â€çš„å¤§å°

            const svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [ -width / 2, -height / 2, width, height ]) // å±…ä¸­åæ ‡ç³»
                .style("max-width", "100%")
                .style("height", "auto");

            const mainG = svg.append("g"); // ä¸»å®¹å™¨

            // å®šä¹‰ç®­å¤´æ ‡è®° (Marker)
            const defs = svg.append("defs");
            defs.append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 18) // ç®­å¤´ä½ç½®å¾®è°ƒ
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#66fcf1");

            // å®šä¹‰å‘å…‰æ»¤é•œ
            const filter = defs.append("filter").attr("id", "glow");
            filter.append("feGaussianBlur").attr("stdDeviation", "2.5").attr("result", "coloredBlur");
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode").attr("in", "coloredBlur");
            feMerge.append("feMergeNode").attr("in", "SourceGraphic");

            // 2. æ™ºèƒ½è®¡ç®—æ‰‡åŒºè§’åº¦ (æŒ‰äººæ•°æ¯”ä¾‹)
            // ç»Ÿè®¡æ¯ä¸ªé˜¶æ®µçš„äººæ•°
            const stageCounts = d3.rollups(friendsData, v => v.length, d => d.stage);
            const stageMap = new Map(stageCounts);
            
            // æ’åºé˜¶æ®µ
            let allStages = Array.from(stageMap.keys());
            allStages.sort((a, b) => {
                let ia = customOrder.indexOf(a);
                let ib = customOrder.indexOf(b);
                if (ia === -1) ia = 999; 
                if (ib === -1) ib = 999;
                return ia - ib;
            });

            // ç”Ÿæˆé¥¼å›¾æ•°æ®æ¥åˆ†é…è§’åº¦
            const pie = d3.pie()
                .value(d => stageMap.get(d)) // æƒé‡ï¼šæ ¹æ®äººæ•°
                .sort(null) // ä¸è‡ªåŠ¨é‡æ–°æ’åºï¼ŒæŒ‰æˆ‘ä»¬æ•´ç†å¥½çš„allStagesæ’
                .padAngle(0.05); // æ‰‡åŒºä¹‹é—´ç•™ç‚¹ç¼éš™

            const arcs = pie(allStages);
            
            // å»ºç«‹ é˜¶æ®µ -> è§’åº¦èŒƒå›´ çš„æ˜ å°„
            const angleMap = {};
            arcs.forEach(d => {
                angleMap[d.data] = {
                    start: d.startAngle,
                    end: d.endAngle,
                    mid: (d.startAngle + d.endAngle) / 2
                };
            });

            // 3. ç»˜åˆ¶æ‰‡åŒºèƒŒæ™¯çº¿å’Œæ–‡å­—
            const sectorG = mainG.append("g").attr("class", "sectors");
            
            arcs.forEach(d => {
                const r = maxRadius + 30; // æ ‡ç­¾è·ç¦»
                const midAngle = (d.startAngle + d.endAngle) / 2;
                // æåæ ‡è½¬ç¬›å¡å°”åæ ‡
                const labelX = Math.sin(midAngle) * r;
                const labelY = -Math.cos(midAngle) * r;

                // ç”»åˆ†å‰²çº¿
                const lineX = Math.sin(d.startAngle) * maxRadius;
                const lineY = -Math.cos(d.startAngle) * maxRadius;
                sectorG.append("line")
                    .attr("x1", 0).attr("y1", 0)
                    .attr("x2", lineX).attr("y2", lineY)
                    .attr("stroke", "rgba(255,255,255,0.08)")
                    .attr("stroke-dasharray", "4,4");

                // é˜¶æ®µæ–‡å­—
                sectorG.append("text")
                    .attr("x", labelX)
                    .attr("y", labelY)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("fill", "#888")
                    .attr("font-size", "14px")
                    .text(d.data);
            });

            // 4. è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„ç†æƒ³ä½ç½® (æåæ ‡)
            const radiusScale = d3.scaleLinear()
                .domain([0, 100])
                .range([centerRadius + 20, maxRadius]);

            const nodes = friendsData.map(d => {
                const angleInfo = angleMap[d.stage];
                // åˆå§‹è§’åº¦è®¾ä¸ºæ‰‡åŒºä¸­é—´ï¼Œå¸¦ä¸€ç‚¹ç‚¹éšæœºé˜²æ­¢å®Œå…¨é‡å 
                const angle = angleInfo.mid + (Math.random() - 0.5) * 0.1;
                const r = radiusScale(d.distance);
                
                // è®¡ç®—ç›®æ ‡æåæ ‡ä½ç½®
                const targetX = Math.sin(angle) * r;
                const targetY = -Math.cos(angle) * r;

                return {
                    ...d,
                    x: targetX, // åˆå§‹ä½ç½®
                    y: targetY,
                    targetX: targetX, // ç‰©ç†å¼•æ“çš„ç›®æ ‡ä½ç½®
                    targetY: targetY,
                    r: r, // æå¾„
                    radius: d.distance < 20 ? 14 : 9 // ç¢°æ’åŠå¾„(çƒä½“å¤§å°)
                };
            });

            // 5. ç‰©ç†å¼•æ“é˜²æ­¢é‡å  (Force Simulation)
            // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†å¾®è°ƒä½ç½®ï¼Œè®©æŒ¤åœ¨ä¸€èµ·çš„çƒåˆ†å¼€ï¼Œä½†åˆå°½é‡ä¿æŒåœ¨åŸæ¥çš„è·ç¦»å’Œè§’åº¦
            const simulation = d3.forceSimulation(nodes)
                .force("x", d3.forceX(d => d.targetX).strength(0.5)) // å¼ºåŠ›æ‹‰å‘åŸæœ¬è¯¥åœ¨çš„ä½ç½®
                .force("y", d3.forceY(d => d.targetY).strength(0.5))
                .force("collide", d3.forceCollide(d => d.radius + 5).iterations(2)) // ç¢°æ’ä½“ç§¯
                .stop();

            // æ‰‹åŠ¨è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿï¼Œç›´æ¥å¾—åˆ°ç¨³å®šç»“æœï¼Œä¸æ˜¾ç¤ºåŠ¨ç”»è¿‡ç¨‹
            for (let i = 0; i < 150; i++) simulation.tick();

            // 6. ç»˜åˆ¶æœ‹å‹é—´çš„å…³ç³»ç½‘ (Requirement 4)
            const relationsG = mainG.append("g").attr("class", "relations-layer");
            
            // æ„å»º name -> node çš„æ˜ å°„
            const nameToNode = {};
            nodes.forEach(n => nameToNode[n.name] = n);

            const validRelations = relationsData.filter(r => nameToNode[r.source] && nameToNode[r.target]);

            const linkPaths = relationsG.selectAll(".rel-link")
                .data(validRelations)
                .enter()
                .append("path")
                .attr("class", "rel-link")
                .attr("d", d => {
                    const s = nameToNode[d.source];
                    const t = nameToNode[d.target];
                    return `M${s.x},${s.y} L${t.x},${t.y}`;
                })
                .attr("stroke", "#66fcf1")
                .attr("stroke-width", 1.5)
                .attr("stroke-opacity", 0.6)
                .attr("fill", "none")
                .attr("stroke-dasharray", d => {
                    if (d.type === 'dotted') return "2,2";
                    if (d.type === 'dashed') return "6,4";
                    return "0";
                })
                .attr("marker-end", d => d.arrow ? "url(#arrow)" : null);

            // å…³ç³»æ–‡å­—æ ‡ç­¾
            const linkLabels = relationsG.selectAll(".rel-label")
                .data(validRelations)
                .enter()
                .append("text")
                .attr("class", "rel-label")
                .attr("x", d => (nameToNode[d.source].x + nameToNode[d.target].x) / 2)
                .attr("y", d => (nameToNode[d.source].y + nameToNode[d.target].y) / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#66fcf1")
                .attr("font-size", "10px")
                .style("background", "black") // ç®€å•æ¨¡æ‹Ÿæè¾¹æ•ˆæœ
                .text(d => d.label);


            // 7. ç»˜åˆ¶è¿çº¿ (è¿å‘åœ†å¿ƒ)
            const linksG = mainG.append("g").attr("class", "center-links");
            linksG.selectAll("line")
                .data(nodes)
                .enter()
                .append("line")
                .attr("x1", 0).attr("y1", 0)
                .attr("x2", d => d.x).attr("y2", d => d.y)
                .attr("stroke", d => d.gender === "å¥³" ? "#ff4d94" : "#00d2ff")
                .attr("stroke-width", 1)
                .attr("opacity", 0.3)
                .attr("stroke-dasharray", d => d.contact ? "0" : "4,4");

            // 8. ç»˜åˆ¶èŠ‚ç‚¹ (æ˜Ÿçƒ)
            const nodesG = mainG.append("g").attr("class", "nodes");
            const circles = nodesG.selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", d => d.distance < 20 ? 12 : 7)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("fill", d => d.gender === "å¥³" ? "#ff4d94" : "#00d2ff")
                .style("filter", "url(#glow)")
                .style("cursor", "pointer")
                .attr("stroke", "#fff")
                .attr("stroke-width", d => d.distance < 20 ? 2 : 0);

            // 9. ç»˜åˆ¶åœ†å¿ƒ (æˆ‘)
            const me = mainG.append("g").style("filter", "url(#glow)");
            me.append("circle").attr("r", 16).attr("fill", "#ffd700");
            me.append("text").attr("y", 5).attr("text-anchor", "middle").attr("fill", "#000")
              .style("font-size", "10px").style("font-weight", "bold").text("æˆ‘");

            // 10. äº¤äº’é€»è¾‘
            const tooltip = d3.select("#tooltip");

            circles.on("mouseover", function(event, d) {
                d3.select(this).transition().attr("r", 18);
                
                // æ„å»ºæ ‡ç­¾HTML
                let tagsHtml = `<span class="tag">${d.stage}</span>`;
                if(d.mbti) tagsHtml += `<span class="tag">${d.mbti}</span>`;
                if(d.personality) tagsHtml += `<span class="tag">${d.personality}</span>`;
                
                tooltip.style("opacity", 1)
                    .html(`
                        <h3>${d.name} <span style="font-size:0.7em;color:#fff;opacity:0.6">${d.gender}</span></h3>
                        <div class="tags">${tagsHtml}</div>
                        <p>â€œ${d.story}â€</p>
                    `);
            })
            .on("mousemove", function(event) {
                // è·Ÿéšé¼ æ ‡
                tooltip.style("left", (event.pageX) + "px")
                       .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function() {
                d3.select(this).transition().attr("r", d => d.distance < 20 ? 12 : 7);
                tooltip.style("opacity", 0);
            });

            // 11. å…³ç³»ç½‘å¼€å…³æ§åˆ¶
            const toggle = document.getElementById('toggleRelations');
            function updateRelations() {
                const opacity = toggle.checked ? 1 : 0;
                relationsG.transition().duration(500).style("opacity", opacity);
            }
            toggle.addEventListener('change', updateRelations);
            updateRelations(); // åˆå§‹åŒ–
        }

        // åˆå§‹åŒ–èƒŒæ™¯æ˜Ÿæ˜Ÿ
        function createStars() {
            for(let i=0; i<150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                const size = Math.random() * 2;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.left = Math.random() * 100 + 'vw';
                star.style.top = Math.random() * 100 + 'vh';
                star.style.animationDuration = (Math.random() * 3 + 2) + 's';
                document.body.appendChild(star);
            }
        }

        // å¯åŠ¨
        createStars();
        init();

        // ç›‘å¬çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°ç»˜åˆ¶ (é˜²æŠ–åŠ¨)
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(init, 300);
        });

    </script>
</body>
</html>
